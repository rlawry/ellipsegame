<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ellipse Game</title>
    <style>
        body {
            background-color: lightSkyBlue;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            position: relative;
        }
        #game{
            position: relative;
            width: 800px;
            height: 800px;
        }
        canvas {
            background-color: black;
            cursor: pointer;
            user-select: none;
        }
        #controls {
            position:absolute;
            top: 20px;
            left: 10%;
            text-align: center;
        }
        #eccentricityInput {
            padding: 5px;
            font-size: 16px;
        }
        #submitEccentricityButton {
            background-color: purple;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            margin-top: 10px;
        }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: white;
            padding: 10px;
            border: 1px solid black;
            font-family: Arial, sans-serif;
        }
        #pointDisplay {
            position:absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            color: lawngreen;
            font-size: 1.5rem;
            margin-bottom: 10px;
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body>
    <div id="game">
        <div id="info">Length: <span id="length">0.0</span> cm</div>
        <canvas id="drawingCanvas" width="800" height="800"></canvas>
        <div id="controls">
            <input type="text" id="eccentricityInput" placeholder="Round to Thousandths">
            <button id="submitEccentricityButton">Submit Eccentricity</button>
        </div>
        <div id="pointDisplay">Points: <span id="pointCounter">0</span></div>
    </div>
    <script>
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            update(x, y) {
                this.x = x;
                this.y = y;
            }
        }


        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const infoSpan = document.getElementById('length');
        const pointCounter = document.getElementById('pointCounter');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        var majorAxis = canvas.width * 0.8;
        var minorAxis = canvas.height * 0.4;
        var running = false;
        

        var trueEccentricity;
        let correctEccentricities = 0;

        //mouse control
        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let endX = 0;
        let endY = 0;

        var gravitationalConstant = 6.67430 * Math.pow(10, -11);
        var massOfSun = 3988500 * Math.pow(10,24);

        var gmSun = gravitationalConstant * massOfSun;
        var satellite = new Point();

        var PLANET = {
            x: null,
            y: null,
            Major_Axis: majorAxis/2,
            Minor_Axis: minorAxis/2,
            orbitalSpeed: null,
            orbitalSpeedActual: null,
            degreeOffset: -360,
            degrees: -180,
            gravitationalConstant: gravitationalConstant,
            MSun: massOfSun,
            GMSun: massOfSun * gravitationalConstant,
            c: 156.12494995995996,
            interval: 1000 / 60,
            day: 1,
        };

        var a = PLANET.Major_Axis * PLANET.Major_Axis;
        var b = PLANET.Minor_Axis * PLANET.Minor_Axis;
        var c = Math.sqrt(a - b);
        PLANET.c = c;

        var time;
        var ecc = 0;


        function drawEllipse(cx,cy,angle){

            trueEccentricity = Math.sqrt(1 - (minorAxis * minorAxis) / (majorAxis * majorAxis));
            // Calculate foci distance
            const fociDistance = Math.sqrt((majorAxis * majorAxis) - (minorAxis * minorAxis));

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(angle);
            // Draw ellipse
            ctx.beginPath();
            ctx.ellipse(0, 0, majorAxis / 2, minorAxis / 2, 0, 0, 2 * Math.PI);
            ctx.strokeStyle = 'white';
            ctx.stroke();
            
            // Draw foci
            drawCross(0 - fociDistance / 2, 0); // Left foci
            drawCross(0 + fociDistance / 2, 0); // Right foci
            ctx.restore();
        }
        
        function startDrawing(event) {
            event.preventDefault(); // Prevent default touch actions like scrolling
            startX = event.type === 'mousedown' ? event.offsetX : event.touches[0].clientX - canvas.getBoundingClientRect().left;
            startY = event.type === 'mousedown' ? event.offsetY : event.touches[0].clientY - canvas.getBoundingClientRect().top;
            isDrawing = true;
        }

        function draw(event) {
            if (isDrawing) {
                event.preventDefault();
                updateLengthDisplay(startX, startY, endX, endY);
                endX = event.type === 'mousemove' ? event.offsetX : event.touches[0].clientX - canvas.getBoundingClientRect().left;
                endY = event.type === 'mousemove' ? event.offsetY : event.touches[0].clientY - canvas.getBoundingClientRect().top;
                clearCanvas();
                drawLine();
            }
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
            }
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawEllipse(centerX,centerY,0);
        }

        function drawLine() {
            ctx.lineWidth = 2;
            ctx.translate(0.5,0.5);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = 'yellow';
            ctx.stroke();

            // Draw short perpendicular line segments at start and end positions
            drawPerpendicularLine(startX, startY, endX, endY, 10);
            drawPerpendicularLine(endX, endY, startX, startY, 10);
            drawPerpendicularLine(startX, startY, endX, endY, -10);
            drawPerpendicularLine(endX, endY, startX, startY, -10);

            updateLengthDisplay(startX, startY, endX, endY);
            ctx.translate(-0.5,-0.5);
        }

        function drawPerpendicularLine(x1, y1, x2, y2, length) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const perpendicularAngle = angle + Math.PI / 2;
            const x3 = x2 + length * Math.cos(perpendicularAngle);
            const y3 = y2 + length * Math.sin(perpendicularAngle);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.stroke();
        }

        function drawCross(x, y) {
            const crossSize = 10;
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - crossSize / 2, y - crossSize / 2);
            ctx.lineTo(x + crossSize / 2, y + crossSize / 2);
            ctx.moveTo(x - crossSize / 2, y + crossSize / 2);
            ctx.lineTo(x + crossSize / 2, y - crossSize / 2);
            ctx.stroke();
        }

        function updateLengthDisplay(x1, y1, x2, y2) {
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)).toFixed(2);
            const lengthInCm = length / canvas.width * canvas.clientWidth * window.devicePixelRatio * 2.54/100; // Convert pixels to centimeters
            infoSpan.textContent = lengthInCm.toFixed(1); // Display length with one decimal place

        }

        function generateNextEllipse(){
            let xy = generateXY();
            majorAxis = canvas.width * xy.X;
            console.log(PLANET.Major_Axis)
            minorAxis = canvas.height * xy.Y;
            PLANET.Major_Axis = majorAxis;
            PLANET.Minor_Axis = minorAxis;
        }

        function generateXY(){
            // Generate a random number between 0.3 and 0.8 for X
            let X = Math.random() * 0.5 + 0.3;

            // Generate a random number between 0.3 and 0.8 for Y
            let Y = Math.random() * 0.5 + 0.3;

            // Ensure X is greater than or equal to Y
            if (X < Y) {
                [X, Y] = [Y, X]; // Swap values if X is less than Y
            }

            return { X, Y };
        }

        function animateRotation() {
            let angle = 0;
            const start = performance.now();

            function animate(currentTime) {
                const elapsedTime = currentTime - start;
                angle = (elapsedTime / 500) * Math.PI; // Adjust speed of rotation here
                drawEllipse(centerX,centerY,angle);
                if (angle < 2 * Math.PI) {
                    requestAnimationFrame(animate);
                }
                else{
                    angle = 2*Math.PI;
                    generateNextEllipse();
                    drawEllipse(centerX,centerY,angle);

                }
            }

            requestAnimationFrame(animate);
        }

        function shakeAnimation(callback) {
            let offset = 0;
            let direction = 1;
            const shakeDistance = 20;
            const start = performance.now();

            function shake(currentTime) {
                const elapsedTime = currentTime - start;
                offset += direction * 2; // Adjust the shaking speed
                if (Math.abs(offset) > shakeDistance) {
                    direction *= -1;
                }

                drawEllipse(centerX + offset, centerY, 0);

                if (elapsedTime < 1000) { // Shake for 1 second
                    requestAnimationFrame(shake);
                } else {
                    angle = 2*Math.PI;
                    drawEllipse(centerX, centerY, 0);
                }
            }

            requestAnimationFrame(shake);
        }

        
        function handleEccentricitySubmission(){
            // Get submitted eccentricity value
            const eccentricityInput = document.getElementById('eccentricityInput').value.trim();
            const decimalRegex = /^0\.\d{3}$/;
            // Parse submitted value to check if it's a number
            if (decimalRegex.test(eccentricityInput)) {
                const submittedEccentricity = parseFloat(eccentricityInput);
                
                // Calculate the true eccentricity of the ellipse

                // Check if the submitted value is a number and matches the true eccentricity
                if (!isNaN(submittedEccentricity) && Math.abs(submittedEccentricity - trueEccentricity) < 0.01) {
                    correctEccentricities++;
                    pointCounter.textContent = correctEccentricities;
                    // Animate rotation
                    animateRotation();
                } else {
                    shakeAnimation();
                }
                console.log("done");
            } else {
                alert('Bad input. Enter a value that looks like 0.000');
            }
        };
        generateNextEllipse();
        // Initialize the canvas background to black
        clearCanvas();



        const submitButton = document.getElementById('submitEccentricityButton');
        submitButton.addEventListener('click', handleEccentricitySubmission);

        // Add event listener for the "Enter" key
        const eccentricityInput = document.getElementById('eccentricityInput');
        eccentricityInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                handleEccentricitySubmission();
            }
        });




        function updateOrbitalSpeedByEllipse(){
            
            PLANET.orbitalSpeed = ((Math.sqrt(((PLANET.gravitationalConstant * (PLANET.MSun)) / (PLANET.Major_Axis * (Math.pow(10, 9)))))) / 1000) * 3600; //Calculate orbital speed in KM/H. Needs radius of planet in METERS!						

        }

        function updateOrbitParameters() {       
            updateOrbitalSpeedByEllipse();
            //document.getElementById("eccentricity").innerHTML= "Eccentricity: " + ecc.toFixed(3);
        }


        function updatePLANET() {

            PLANET.orbitalSpeedActual = calculateOrbitalSpeedPLANET(); //Update orbital speed after each frame						

            PLANET.degrees = PLANET.degrees - (((360 / 365.256) * ((PLANET.orbitalSpeedActual / PLANET.orbitalSpeed))));

            PLANET.day++;

            if (roundPLANET(PLANET.day, 0) == roundPLANET(456 / 10 * 9, 0)) {
                //alert(PLANET.degrees);
            }

            if (PLANET.degrees < -360 - PLANET.degreeOffset) {
                PLANET.degrees = 0 - PLANET.degreeOffset;
                PLANET.day = 1;
            }
            updateOrbitParameters();

        }

        function calculateOrbitalSpeedPLANET() {

            var tx = ((PLANET.Major_Axis) * Math.cos(toRadiansPLANET(PLANET.degrees))) + PLANET.c; //C has to be subtracted AFTER the calculation for it to work!!
            var ty = ((PLANET.Minor_Axis) * Math.sin(toRadiansPLANET(PLANET.degrees)));
            var speed = ((Math.sqrt((PLANET.GMSun) * ((2 / ((Math.sqrt((Math.pow(tx, 2)) + (Math.pow(ty, 2)))) * (Math.pow(10, 9)))) - (1 / (PLANET.Major_Axis * (Math.pow(10, 9))))))) / 1000) * 3600 - c;
            infoSpan.innerHTML = speed.toFixed(0);
            return speed;
        }

        function renderPointPLANET() {
            var x = ((PLANET.Major_Axis/2) * Math.cos(toRadiansPLANET(PLANET.degrees)));
            var y = ((PLANET.Minor_Axis)/2 * Math.sin(toRadiansPLANET(PLANET.degrees)));
            satellite.update(x, y);
            drawPlanet(satellite.x,satellite.y);
        }

        function drawPlanet(x,y){
            ctx.fillStyle = "lightblue";
            ctx.strokeStyle = "blue";
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.moveTo(0-x-majorAxis/2,0-y-minorAxis/2);
            const planetDiameter = 4;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();
            ctx.restore();
        }

        //#BEGIN USEFUL FUNCTIONS SECTION II
        function toRadiansPLANET(value) {
            return value * (Math.PI / 180);
        }

        function roundPLANET(value, decimals) {
            return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
        }

        let animationFrameId;

        function animatePlanet(){
            drawEllipse(centerX, centerY, 0);
            if(running){  
                updatePLANET();
                renderPointPLANET();
            }
            console.log(PLANET.degrees + "°");
            animationFrameId = requestAnimationFrame(animatePlanet);
        }

        document.body.onkeyup = function(e){
            if(e.keyCode == 32){
                if(running){
                    running = false;
                    updatePLANET();
                    cancelAnimationFrame(animationFrameId)
                    PLANET.degrees = 0 - PLANET.degreeOffset;
                    PLANET.day = 1;
                    updatePLANET();
                }
                else if(!running){
                    running = true;
                    animationFrameId = requestAnimationFrame(animatePlanet);
                }
            }
        }



    </script>
</body>
</html>
